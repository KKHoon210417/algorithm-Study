# Q17 경쟁적 전염

# N X N 크기의 시험관이 있다.
# 특정한 위치에 바이러스가 존재할 수 있다.
# 바이러스의 종류는 1 ~ K번까지 K가지가 있으며, 모든 바이러스는 이 중 하나에 속합니다.
# 모든 바이러스는 1초마다 상, 하, 좌, 우의 방향으로 증식하는데, 매초 번호가 낮은 종류의 바이러스부터 먼저 증식한다.
# 또한 증식 과정에서 특정한 칸에 이미 어떠한 바이러스가 있다면, 그곳에는 다른 바이러스가 들어갈 수 없습니다.
# 시험관의 크기와 바이러스의 위치 정보가 주어졌을 때, S초가 지난 후에 (X, Y)에 존재하는 바이러스의 종류를 출력하는 프로그램을 작성하시오.
# 만약 S초가 지난후 (X, Y)에 존재하는 바이러스가 존재하지 않는다면, 0을 출력합니다. 이때, X와 Y는 각각 행과 열의 위치를 의미하며,
# 시험관의 가장 왼쪽 위에 해당하는 곳은 (1,1)에 해당합니다.

# 입력 조건
# 1. 첫째 줄에 자연수 N, K가 주어지며, 각 자연수는 공백으로 구분합니다.
# 2. 둘째 줄부터 N개의 줄에 걸쳐서 시험관의 정보가 주어집니다. 각 행은 N개의 원소로 구성되며, 해당 위치에 바이러스가 존재하지 않는 경우 0이
#   주어집니다. 또한 모든 바이러스의 번호는 K이하의 자연수로만 주어집니다.
# 3. N + 2번째 줄에는 S, X, Y가 주어지며 공백으로 구분합니다.

# 출력 조건
# 1. S초 뒤에 (X, Y)에 존재하는 바이러스의 종류를 출력합니다. 만약 S초 뒤에 해당 위치에 바이러스가 존재하지 않는다면, 0을 출력합니다.

# 접근 방법
# 1. 각 바이러스의 이동 시간이 1로 동일하므로, 바이러스의 번호가 낮은 순서로 BFS를 실행한다.
# 2. 바이러스 별 이동 거리(시간)을 저장할 리스트를 만듭니다.
# 3. 바이러스가, 실제 시험관 내에서 이동할때, 바이러스 별 이동 거리(시간) 리스트도 같이 업데이트한다.

# 접근 방법_풀이
# 1. 각 바이러스의 이동 시간이 1로 동일하므로, 바이러스의 번호가 낮은 순서로 BFS를 실행한다.
# 2. 낮은 순서로 BFS를 실행시키기 위해 초기 큐에 바이러스의 번호가 낮은 순서대로 삽입해 놓는다.

# 풀이
from collections import deque

n, k = map(int, input().split())

graph = [] # 전체 보드 정보를 담는 리스트
data = [] # 바이러스에 대한 정보를 담는 리스트

for i in range(n):
    # 보드 정보를 한 줄 단위로 입력
    graph.append(list(map(int, input().split())))
    for j in range(n):
        # 해당 위치에 바이러스가 존재하는 경우
        if graph[i][j] != 0:
            # 바이러스의 종류, 시간, x위치, y위치 저장
            data.append((graph[i][j], 0, i, j))

# 정렬 이후에 큐로 옮기기(낮은 번호의 바이러스가 먼저 증식하도록)
data.sort()
q = deque(data)

target_s, target_x, target_y = map(int, input().split())

# 바이러스가 퍼져나갈 수 있는 4가지 위치
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 너비 우선 탐색(BFS) 진행
while q:
    virus, s, x, y = q.popleft()
    # 정확히 S초가 지나가거나, 큐가 빌 때까지 반복
    if s == target_s:
        break

    # 현재 노드에서 주변 4가지 위치를 각각 확인
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        # 해당 위치로 이동할 수 있는 경우
        if 0 <= nx and nx < n and 0 <= ny and ny < n:
            # 아직 방문하지 않은 위치라면, 그 위치에 바이러스 넣기
            if graph[nx][ny] == 0:
                graph[nx][ny] = virus
                q.append((virus, s + 1, nx, ny))

print(graph[target_x - 1][target_y - 1])